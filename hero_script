local DIRECTION_RIGHT = 1
local DIRECTION_LEFT = -1
local BASE_VELOCITY = 250
local GRAVITY = 1000
local JUMP_TAKEOFF = 600
local MAX_HEALTH = 2

function init(self)

	self.enabled = false
	msg.post("#", "acquire_input_focus")
	msg.post("@render:", "use_camera_projection")
	msg.post("operator#camera", "aquire_camera_focus")
	msg.post("#", "acquire_input_focus")
	self.velocity = vmath.vector3(0, 0, 0)
	self.ground_contact = false
	self.previous_ground_contact = false
	self.correction = vmath.vector3(0, 0, 0)
	self.respawn_position = go.get_world_position()
	self.health = MAX_HEALTH
	self.transformed = false
	self.dead = false

	if self.dead == true then
		msg.post("main:/gameover#gameover", "show")
	end
	
	
	if self.transformed == false and not self.transformed == true then
		sound.play("#bgm")
	end
	
end

function walk(self)
	self.velocity.x = BASE_VELOCITY * self.direction
end

function flip(direction)
	sprite.set_hflip("#sprite", direction < 0)
end

function play_animation(self, new_animation)
	if self.animation ~= new_animation then
		sprite.play_flipbook("#sprite", new_animation)
		self.animation = new_animation
	end
end

function animate(self)
	local idle_anim  = self.transformed and "idle2" or "idle"
	local run_anim   = self.transformed and "run2"  or "run"
	local jump_anim  = self.transformed and "jump2" or "jump"

	if self.ground_contact then
		if self.velocity.x == 0 then
			play_animation(self, idle_anim)
		else
			play_animation(self, run_anim)
		end
	else
		play_animation(self, jump_anim)
	end
end

--clamp a number between a min and max value
local function clamp(v, min, max)
	if v < min then return min
	elseif v > max then return max
	else return v end
end


function handle_level_collisions(self, normal, distance)

	if distance > 0 then
		--project accumulated correction onto the penetration vector
		local extent = vmath.project(self.correction, normal * distance)
		if extent < 1 then -- exclude overshoot projection
			local compensation = (distance - distance * extent) * normal
			go.set_position(go.get_position() + compensation) -- apply compensation instantly
			self.correction = self.correction + compensation -- accumulate the correction
		end
	end
	
	--wall on left or right
	if math.abs(normal.x) > 0 then
		self.velocity.x = 0
	end
	
	--on the ground
	if normal.y > 0 then
		if not self.previous_ground_contact then
			particlefx.play("#sparkle")
			sound.play("#land")
		end
		self.ground_contact = true
		self.velocity.y = 0
	end

	--hit the ceiling
	if normal.y < 0 then
		self.velocity.y = 0
	end
end

function on_message(self, message_id, message, sender)

	if message_id == hash("enable_player") then
		self.enabled = true
		msg.post("#", "acquire_input_focus")
	elseif message_id == hash("disable_player") then
		self.enabled = false
		msg.post("#", "release_input_focus")
	end
	
	if (message_id == hash("contact_point_response"))
	and message.other_group == hash("level") then
		handle_level_collisions(self, message.normal, message.distance)

	elseif message_id == hash("reset_player") then
		print("Resetting player...")

		-- Reset position to start
		go.set_position(vmath.vector3(110,368,1.2))

		-- Reset velocity & physics state
		self.velocity = vmath.vector3(0, 0, 0)
		self.ground_contact = false
		self.previous_ground_contact = false
		self.correction = vmath.vector3(0, 0, 0)
		self.transformed = false
		particlefx.stop("#petal")

		-- Reset health
		self.health = MAX_HEALTH

		-- Reset checkpoint
		self.respawn_position = vmath.vector3(0,0,0)

		-- Enable hero
		self.enabled = true
		go.set(".", "enabled", true)
		msg.post("#", "acquire_input_focus")
		
	elseif message_id == hash("set_checkpoint") then
		self.respawn_position = message.position
		print("Checkpoint updated!", message.position)
		

	elseif message_id == hash("take_damage") then 
		if self.dead then return end 
		play_animation(self, "damage") 
		self.health = self.health - message.amount 
		msg.post("main:/gui#main", "update_health", { health = self.health }) 
		print("Player health:", self.health)

		-- If player dies
		if self.health <= 0 then
			-- Respawn at checkpoint 
			go.set_position(self.respawn_position) 
			self.velocity = vmath.vector3(0, 0, 2) 
			self.health = MAX_HEALTH
			self.dead = false
			msg.post("main:/gui#main", "update_health", { health = self.health }) 
			
		elseif self.transformed and self.health <= 0 then
			self.dead = true

			-- Disable player completely
			self.enabled = false
			msg.post("#", "release_input_focus")
			go.set(".", "enabled", false)

			-- Hide sprite
			sprite.set_enabled("#sprite", false)

			-- Trigger game over screen
			msg.post("main:/gameover#gameover", "show")

			return
			
		end
	end

	if message_id == hash("close_note") then
		print("Player transformation triggered!")
		self.transformed = true
		sound.play("#bgm2")
		particlefx.play("#petal")
		msg.post("main:/exit#exit1", "enable_checkpoint")
		print("Player reached checkpoint and is transformed.")
		

	elseif message_id == hash("contact_point_response") 
	and message.other_group == hash("checkpoint") then

		if self.transformed then
			print("Player reached checkpoint and is transformed.")
			msg.post("main:/exit#exit1", "enable_checkpoint")
		else
			print("Player reached checkpoint but is NOT transformed.")
		end
	end
	
	
end

function on_input(self, action_id, action)	
	if not self.enabled then return end
	if self.dead then return end
	if action_id == hash("interact") and action.pressed then
		print("INTERACT!")
	end
	
	if action_id == hash("interact") and action.pressed then
			msg.post("/note#note", "interact_attempt")
	end
	

	-- movement
	if action_id == hash("left") then
		self.direction = DIRECTION_LEFT
		walk(self)
		flip(self.direction)
		
	elseif action_id == hash("right") then
		self.direction = DIRECTION_RIGHT
		walk(self)
		flip(self.direction)
	end

	-- jumping
	if action_id == hash("jump") and action.pressed and self.ground_contact then
		self.velocity.y = JUMP_TAKEOFF
		self.ground_contact = false
		particlefx.play("#sparkle")
		sound.play("#jump")
	end
end


local function respawn(self)
	go.set_position(self.respawn_position)
	self.velocity = vmath.vector3(0, 0, 2)
	self.ground_contact = true   -- prevents immediate falling
end

function fixed_update(self, dt)
	if self.dead then return end
	-- check for falling out before applying gravity/movement
	local pos = go.get_position()
	if pos.y < -50 then
		respawn(self)
	end
	
	self.velocity.y = self.velocity.y - GRAVITY * dt
	self.velocity.y = clamp(self.velocity.y, -2000, 2000)

	if self.ground_contact then
		self.velocity.y = 0
	end
	self.previous_ground_contact = self.ground_contact

	local position = go.get_position()
	position = position + self.velocity * dt
	go.set_position(position)

	animate(self)

	self.velocity.x = 0
	self.ground_contact = false
	self.correction.x = 0
	self.correction.y = 0
end
